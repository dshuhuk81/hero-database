---
// ShrineSparkles.astro
// Drop this component on top of your shrine background image.
// Usage: <ShrineSparkles />
---

<div class="shrine-wrapper">
  <!-- Your background image -->
  <img
    src="/shrineBG.webp"
    alt="Shrine background"
    class="shrine-bg"
  />

  <!-- Spark canvas overlay -->
  <canvas id="sparkCanvas" class="spark-overlay" aria-hidden="true"></canvas>
</div>

<style>
  .shrine-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
    overflow: hidden;
    line-height: 0;
  }

  .shrine-bg {
    width: 100%;
    height: auto;
    display: block;
  }

  .spark-overlay {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
</style>

<script>
  const canvas = document.getElementById('sparkCanvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // ─── Resize canvas to match its CSS size ────────────────────────────────────
  function resize() {
    canvas.width  = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // ─── Spark type ─────────────────────────────────────────────────────────────
  interface Spark {
    x: number;
    y: number;
    vx: number;          // horizontal drift
    vy: number;          // upward speed (negative = up)
    size: number;        // radius of core
    alpha: number;       // current opacity
    life: number;        // 0 → 1 progress through lifetime
    lifeSpeed: number;   // how fast it ages per frame
    twinkle: number;     // phase offset for shimmer
    color: string;       // hsl tint
  }

  const sparks: Spark[] = [];

  // Spawn zone: the central blue column in the image (roughly 30-70% width)
  function spawnSpark(): Spark {
    const w = canvas.width;
    const h = canvas.height;

    // Weighted towards centre-bottom of the shrine portal
    const xMin = w * 0.35;
    const xMax = w * 0.65;
    const yMin = h * 0.55;   // bottom of the portal
    const yMax = h * 0.95;

    return {
      x: xMin + Math.random() * (xMax - xMin),
      y: yMin + Math.random() * (yMax - yMin),
      vx: (Math.random() - 0.5) * 0.6,
      vy: -(0.6 + Math.random() * 1.4),          // upward
      size: 1.2 + Math.random() * 3.5,
      alpha: 0,
      life: 0,
      lifeSpeed: 0.004 + Math.random() * 0.006,   // controls total lifetime
      twinkle: Math.random() * Math.PI * 2,
      // Blue-cyan-white range
      color: `hsl(${200 + Math.random() * 40}, 100%, ${75 + Math.random() * 25}%)`,
    };
  }

  // Pre-populate pool
  for (let i = 0; i < 60; i++) {
    const s = spawnSpark();
    s.life = Math.random();   // stagger initial positions
    sparks.push(s);
  }

  // ─── Draw a single 4-pointed star spark ─────────────────────────────────────
  function drawStar(
    x: number,
    y: number,
    size: number,
    alpha: number,
    color: string,
    twinkle: number,
    time: number
  ) {
    const shimmer = 0.7 + 0.3 * Math.sin(time * 6 + twinkle);
    const a = alpha * shimmer;
    if (a <= 0) return;

    ctx.save();
    ctx.globalAlpha = a;
    ctx.translate(x, y);

    // Outer glow
    const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 5);
    glow.addColorStop(0,   'rgba(120,220,255,0.35)');
    glow.addColorStop(1,   'rgba(30,100,255,0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, size * 5, 0, Math.PI * 2);
    ctx.fill();

    // 4-pointed star beams
    const long  = size * 4.5;
    const short = size * 2.5;
    const thin  = size * 0.25;

    const drawBeam = (angle: number, len: number) => {
      ctx.save();
      ctx.rotate(angle);
      const grad = ctx.createLinearGradient(-len, 0, len, 0);
      grad.addColorStop(0,   'rgba(255,255,255,0)');
      grad.addColorStop(0.5, color);
      grad.addColorStop(1,   'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, len, thin, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    };

    drawBeam(0,              long);    // horizontal
    drawBeam(Math.PI / 2,    long);    // vertical
    drawBeam(Math.PI / 4,    short);   // diagonal ↗
    drawBeam(-Math.PI / 4,   short);   // diagonal ↘

    // White core
    const core = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
    core.addColorStop(0, 'white');
    core.addColorStop(1, 'rgba(120,220,255,0)');
    ctx.fillStyle = core;
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // ─── Animation loop ─────────────────────────────────────────────────────────
  let t = 0;
  function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    t += 0.016;

    for (const s of sparks) {
      // Age
      s.life += s.lifeSpeed;

      // Ease in / ease out alpha curve (bell shape)
      const progress = s.life;          // 0 → 1
      s.alpha = progress < 0.2
        ? progress / 0.2               // fade in
        : progress < 0.75
          ? 1                          // fully visible
          : 1 - (progress - 0.75) / 0.25; // fade out

      s.alpha = Math.max(0, Math.min(1, s.alpha));

      // Move upward + gentle sway
      s.x += s.vx + Math.sin(t * 1.5 + s.twinkle) * 0.15;
      s.y += s.vy;

      drawStar(s.x, s.y, s.size, s.alpha, s.color, s.twinkle, t);

      // Reset when lifetime complete
      if (s.life >= 1) {
        Object.assign(s, spawnSpark());
      }
    }

    requestAnimationFrame(tick);
  }

  tick();
</script>
