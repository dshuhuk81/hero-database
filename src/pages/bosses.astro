---
import bosses from "../data/bosses.json";
import { getHeroById, statMaxima } from "../data/heroes";
import Sidebar from "../components/Sidebar.astro";
import Footer from "../components/Footer.astro";
import "../styles/compositions.css";
import teamCompsByHeroId from "../data/derived/teamCompsByHeroId.json";
import { resolveAutoComp } from "../utils/bossAutoComp";

const RATING_VALUE = { SSS: 10, SS: 9, S: 8, A: 6, B: 4, C: 2, D: 1 };
const DAMAGE_STATS = ["atk", "critRate", "critDmgBonus"];

function ratingValue(raw) {
  const key = String(raw || "C").toUpperCase();
  return RATING_VALUE[key] ?? 2;
}

function teamPveAvg(comp) {
  const heroes = comp?.summary?.heroes ?? [];
  if (!heroes.length) return 0;
  const vals = heroes.map(h => ratingValue(h?.pve ?? h?.overall));
  return vals.reduce((a, b) => a + b, 0) / vals.length;
}

function teamDamageScore(comp) {
  const ids = comp?.team ?? [];
  const stats = DAMAGE_STATS.filter(
    key => typeof statMaxima?.[key] === "number" && statMaxima[key] > 0
  );
  if (!ids.length || !stats.length) return 0;

  let total = 0;
  let count = 0;
  for (const id of ids) {
    const hero = getHeroById(id);
    if (!hero) continue;
    for (const stat of stats) {
      const max = statMaxima[stat] || 0;
      const val = Number(hero?.stats?.[stat] ?? 0);
      if (max > 0) {
        total += Math.max(0, val) / max;
        count += 1;
      }
    }
  }

  return count ? total / count : 0;
}

function hasSupport(comp) {
  const summaryHeroes = comp?.summary?.heroes ?? [];
  if (summaryHeroes.length) {
    return summaryHeroes.some(
      h => String(h?.class || "").toLowerCase() === "support"
    );
  }

  const ids = comp?.team ?? [];
  return ids.some(
    id => String(getHeroById(id)?.class || "").toLowerCase() === "support"
  );
}

function teamKey(team) {
  return [...team].sort().join("|");
}

function countTeamTags(comp) {
  const counts = {};
  const heroes = comp?.summary?.heroes ?? [];
  for (const h of heroes) {
    for (const t of (h?.tags ?? [])) {
      counts[t] = (counts[t] || 0) + 1;
    }
  }
  return counts;
}

function buildCandidate(comp, rules) {
  if (!hasSupport(comp)) return null;

  const tagCounts = countTeamTags(comp);
  const min = rules?.minTagCounts ?? {};

  for (const [tag, n] of Object.entries(min)) {
    if ((tagCounts[tag] || 0) < n) return null;
  }

  return {
    comp,
    tagCounts,
    rankingScore: Number(comp?.rankingScore ?? 0),
    pveAvg: teamPveAvg(comp),
    damageScore: teamDamageScore(comp),
    synergyCount: Array.isArray(comp?.synergy) ? comp.synergy.length : 0,
  };
}

function normalize(value, max) {
  if (!max || max <= 0) return 0;
  return value / max;
}

function scoreCandidate(candidate, rules, maxima) {
  const prefer = rules?.preferHeroTags ?? [];
  const avoid = rules?.avoidHeroTags ?? [];

  const rankingPart = normalize(
    candidate.rankingScore + candidate.synergyCount * 5,
    maxima.rankingScore
  );
  const pvePart = normalize(candidate.pveAvg, maxima.pveAvg);
  const dmgPart = normalize(candidate.damageScore, maxima.damageScore);
  const synergyPart = normalize(candidate.synergyCount, maxima.synergyCount) * 0.05;

  let tagBonus = 0;
  for (const t of prefer) tagBonus += (candidate.tagCounts[t] || 0) * 0.02;
  for (const t of avoid) tagBonus -= (candidate.tagCounts[t] || 0) * 0.03;

  return rankingPart * 0.4 + pvePart * 0.4 + dmgPart * 0.2 + synergyPart + tagBonus;
}

function pickBestCandidate(candidates, rules) {
  if (!candidates.length) return null;

  const maxima = candidates.reduce(
    (acc, c) => {
      acc.rankingScore = Math.max(acc.rankingScore, c.rankingScore + c.synergyCount * 5);
      acc.pveAvg = Math.max(acc.pveAvg, c.pveAvg);
      acc.damageScore = Math.max(acc.damageScore, c.damageScore);
      acc.synergyCount = Math.max(acc.synergyCount, c.synergyCount);
      return acc;
    },
    { rankingScore: 0, pveAvg: 0, damageScore: 0, synergyCount: 0 }
  );

  let best = null;
  let bestScore = -Infinity;
  for (const candidate of candidates) {
    const score = scoreCandidate(candidate, rules, maxima);
    if (score > bestScore) {
      bestScore = score;
      best = candidate;
    }
  }

  return best;
}

function resolveAutoHeroes({ mode = "pve", autoRules }) {
  // collect all comps for that mode, dedupe by team set
  const pool = [];
  for (const heroId of Object.keys(teamCompsByHeroId || {})) {
    const comps = teamCompsByHeroId?.[heroId]?.[mode] ?? [];
    for (const c of comps) if (Array.isArray(c?.team) && c.team.length === 5) pool.push(c);
  }

  function collectCandidates(rules) {
    const bestByKey = new Map();
    for (const c of pool) {
      const candidate = buildCandidate(c, rules);
      if (!candidate) continue;

      const k = teamKey(c.team);
      const prev = bestByKey.get(k);
      if (!prev || candidate.rankingScore > prev.rankingScore) {
        bestByKey.set(k, candidate);
      }
    }
    return [...bestByKey.values()];
  }

  const primaryCandidates = collectCandidates(autoRules);
  let best = pickBestCandidate(primaryCandidates, autoRules);

  if (!best) {
    const fallbackCandidates = collectCandidates(null);
    best = pickBestCandidate(fallbackCandidates, null);
  }

  return best?.comp?.team ?? [];
}

function getBossModeDefault(boss) {
  // minimal: Torment Rift & Grim Surge sind praktisch PvE
  return "pve";
}
function heroName(id) {
  return getHeroById(id)?.name ?? id;
}

function heroImage(id) {
  const img = getHeroById(id)?.image;
  return img?.startsWith("/") ? img : `/${img}`;
}

function factionIcon(faction) {
  return `/icons/factions/${String(faction || "").toLowerCase()}.webp`;
}

function classIcon(heroClass) {
  return `/icons/classes/${String(heroClass || "").toLowerCase()}.webp`;
}

const BOSS_SKILL_ICON_ALIAS = {
  isthar_vi: "ishtar",
};

function bossSkillIcon(bossId, index) {
  const key = BOSS_SKILL_ICON_ALIAS[bossId] || bossId;
  return `/bosses/${key}_skill_${index + 1}.png`;
}
---

<Sidebar />

<section class="boss-page">
  <div class="boss-carousel">
    <button class="boss-nav boss-nav-left" aria-label="Previous boss" type="button">
      <span aria-hidden="true">&#x2039;</span>
    </button>
    <button class="boss-nav boss-nav-right" aria-label="Next boss" type="button">
      <span aria-hidden="true">&#x203A;</span>
    </button>

    <div class="boss-slides" data-boss-slides>
      {bosses.bosses.map((boss, index) => (
        <article class="boss-slide" data-boss-slide data-index={index}>
          <div class="boss-layout">
            <div class="boss-image-wrap">
              <img class="boss-image" src={boss.image} alt={boss.name} />
            </div>

            <div class="boss-content">
              <div class="boss-title">
                <p class="boss-kicker">Boss Encounter</p>
                <h2>{boss.name}</h2>
                <div class="boss-meta">
                  <span class="pill">{boss.mode}</span>
                  <span class="pill pill-icon">
                    <img
                      class="meta-icon"
                      src={factionIcon(boss.faction)}
                      alt={boss.faction}
                    />
                    {boss.faction}
                  </span>
                  <span class="pill pill-icon">
                    <img
                      class="meta-icon"
                      src={classIcon(boss.class)}
                      alt={boss.class}
                    />
                    {boss.class}
                  </span>
                  <span class="pill">BP {boss.battlepower}</span>
                </div>
                {boss.summary && <p class="boss-summary">{boss.summary}</p>}
              </div>

              <div class="boss-skills">
                <h3>Mechanics</h3>
                <ul>
                  {boss.skills.map((sk, skillIndex) => (
                    <li class="boss-skill">
                      {sk.type !== "Passive" ? (
                        <img
                          class="skill-icon"
                          src={bossSkillIcon(boss.id, skillIndex)}
                          alt={`${boss.name} ${sk.name}`}
                          loading="lazy"
                        />
                      ) : null}
                      <div>
                        <strong>{sk.name}</strong> <small>({sk.type})</small>
                        <div class="boss-skill-desc">{sk.description}</div>
                      </div>
                    </li>
                  ))}
                </ul>
              </div>

              <div class="boss-comps">
                {boss.recommendedComps.map(comp => {
                  const isAuto = comp.source === "auto";
                  const compResolved = isAuto
                    ? resolveAutoComp(comp, boss, bosses.autoRules)
                    : comp;

                  const resolvedHeroes =
                    isAuto && (!compResolved.heroes || compResolved.heroes.length === 0)
                      ? resolveAutoHeroes({
                          mode: getBossModeDefault(boss),
                          autoRules: compResolved.autoRules,
                        })
                      : (compResolved.heroes ?? []);

                  return (
                    <div class="comp-block">
                      <h3>{comp.label}</h3>

                      <div class="boss-meta" style="margin: 6px 0 10px;">
                        <span class="pill">{isAuto ? "Auto" : "Manual"}</span>
                      </div>

                      <div class="comp-heroes">
                        {resolvedHeroes.map(id => (
                          <div class="hero-mini">
                            <img src={heroImage(id)} alt={heroName(id)} />
                            <span>{heroName(id)}</span>
                          </div>
                        ))}
                      </div>

                      <p class="reason">{comp.reason}</p>

                      {comp.notes?.length ? (
                        <ul class="notes">
                          {comp.notes.map(n => <li>{n}</li>)}
                        </ul>
                      ) : null}

                      {isAuto && compResolved.autoRules?.notes ? (
                        <p class="reason" style="opacity:.7; margin-top:10px;">
                          <em>{compResolved.autoRules.notes}</em>
                        </p>
                      ) : null}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </article>
      ))}
    </div>
  </div>
</section>

<script>
  const slides = Array.from(document.querySelectorAll("[data-boss-slide]"));
  const prevBtn = document.querySelector(".boss-nav-left");
  const nextBtn = document.querySelector(".boss-nav-right");
  let currentIndex = 0;

  function updateSlides(index) {
    currentIndex = (index + slides.length) % slides.length;
    slides.forEach((slide, i) => {
      slide.classList.toggle("is-active", i === currentIndex);
    });
  }

  if (slides.length) {
    updateSlides(0);
  }

  prevBtn?.addEventListener("click", () => updateSlides(currentIndex - 1));
  nextBtn?.addEventListener("click", () => updateSlides(currentIndex + 1));

  document.addEventListener("keydown", event => {
    if (event.key === "ArrowLeft") updateSlides(currentIndex - 1);
    if (event.key === "ArrowRight") updateSlides(currentIndex + 1);
  });
</script>

<Footer />
